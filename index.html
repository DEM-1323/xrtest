<!DOCTYPE html>
<html>
<head>
    <title>WebGPU WebXR Demo</title>
    <style>
        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        #xr-button {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            background: #4CAF50;
            color: white;
            font-size: 16px;
            cursor: pointer;
        }
        #xr-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <canvas></canvas>
    <button id="xr-button" disabled>Enter VR</button>
    <script>
        async function init() {
            if (!navigator.gpu) {
                alert('WebGPU not supported');
                return;
            }

            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                alert('Couldn\'t request WebGPU adapter');
                return;
            }

            const device = await adapter.requestDevice();
            const canvas = document.querySelector('canvas');
            const context = canvas.getContext('webgpu');

            const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
            context.configure({
                device,
                format: canvasFormat,
                alphaMode: 'premultiplied',
            });

            // Create vertex buffer
            const vertices = new Float32Array([
                 0.0,  0.5, 0.0, // position
                -0.5, -0.5, 0.0,
                 0.5, -0.5, 0.0,
            ]);

            const vertexBuffer = device.createBuffer({
                size: vertices.byteLength,
                usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
            });
            device.queue.writeBuffer(vertexBuffer, 0, vertices);

            const vertexBufferLayout = {
                arrayStride: 12, // 3 floats * 4 bytes
                attributes: [{
                    format: 'float32x3',
                    offset: 0,
                    shaderLocation: 0,
                }],
            };

            // Create shader
            const shaderModule = device.createShaderModule({
                code: `
                    struct VertexOutput {
                        @builtin(position) position: vec4f,
                        @location(0) color: vec4f,
                    }

                    @vertex
                    fn vertexMain(
                        @location(0) position: vec3f,
                    ) -> VertexOutput {
                        var output: VertexOutput;
                        output.position = vec4f(position, 1.0);
                        output.color = vec4f(1.0, 0.0, 0.0, 1.0);
                        return output;
                    }

                    @fragment
                    fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {
                        return input.color;
                    }
                `
            });

            // Create render pipeline
            const pipeline = device.createRenderPipeline({
                layout: 'auto',
                vertex: {
                    module: shaderModule,
                    entryPoint: 'vertexMain',
                    buffers: [vertexBufferLayout],
                },
                fragment: {
                    module: shaderModule,
                    entryPoint: 'fragmentMain',
                    targets: [{
                        format: canvasFormat,
                    }],
                },
                primitive: {
                    topology: 'triangle-list',
                },
            });

            // WebXR session setup
            const xrButton = document.querySelector('#xr-button');
            
            if ('xr' in navigator) {
                const sessionInit = {
                    requiredFeatures: ['local'],
                };

                navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                    xrButton.disabled = !supported;
                });

                xrButton.addEventListener('click', async () => {
                    try {
                        const session = await navigator.xr.requestSession('immersive-vr', sessionInit);
                        const xrLayer = new XRWebGPULayer(session, device);
                        const xrRefSpace = await session.requestReferenceSpace('local');

                        await session.updateRenderState({
                            baseLayer: xrLayer
                        });

                        function onXRFrame(time, frame) {
                            const pose = frame.getViewerPose(xrRefSpace);
                            
                            if (pose) {
                                const commandEncoder = device.createCommandEncoder();
                                
                                for (const view of pose.views) {
                                    const renderPass = commandEncoder.beginRenderPass({
                                        colorAttachments: [{
                                            view: xrLayer.getViewTextureView(view),
                                            clearValue: { r: 0.1, g: 0.1, b: 0.1, a: 1.0 },
                                            loadOp: 'clear',
                                            storeOp: 'store',
                                        }],
                                    });

                                    renderPass.setPipeline(pipeline);
                                    renderPass.setVertexBuffer(0, vertexBuffer);
                                    renderPass.draw(3);
                                    renderPass.end();
                                }

                                device.queue.submit([commandEncoder.finish()]);
                            }

                            session.requestAnimationFrame(onXRFrame);
                        }

                        session.requestAnimationFrame(onXRFrame);

                    } catch (error) {
                        console.error('Error entering VR:', error);
                    }
                });
            }

            // Regular rendering loop for non-VR
            function render() {
                const commandEncoder = device.createCommandEncoder();
                const renderPass = commandEncoder.beginRenderPass({
                    colorAttachments: [{
                        view: context.getCurrentTexture().createView(),
                        clearValue: { r: 0.1, g: 0.1, b: 0.1, a: 1.0 },
                        loadOp: 'clear',
                        storeOp: 'store',
                    }],
                });

                renderPass.setPipeline(pipeline);
                renderPass.setVertexBuffer(0, vertexBuffer);
                renderPass.draw(3);
                renderPass.end();

                device.queue.submit([commandEncoder.finish()]);
                requestAnimationFrame(render);
            }

            requestAnimationFrame(render);
        }

        init();
    </script>
</body>
</html>
